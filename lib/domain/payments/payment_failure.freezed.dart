// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'payment_failure.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$PaymentFailure {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unexpected,
    required TResult Function() insufficientFunds,
    required TResult Function() invalidCard,
    required TResult Function() storeNotAvailable,
    required TResult Function() noProductsAvailable,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unexpected,
    TResult? Function()? insufficientFunds,
    TResult? Function()? invalidCard,
    TResult? Function()? storeNotAvailable,
    TResult? Function()? noProductsAvailable,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unexpected,
    TResult Function()? insufficientFunds,
    TResult Function()? invalidCard,
    TResult Function()? storeNotAvailable,
    TResult Function()? noProductsAvailable,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Unexpected value) unexpected,
    required TResult Function(_InsufficientFunds value) insufficientFunds,
    required TResult Function(_InvalidCard value) invalidCard,
    required TResult Function(_StoreNotAvailable value) storeNotAvailable,
    required TResult Function(_NoProductsAvailable value) noProductsAvailable,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Unexpected value)? unexpected,
    TResult? Function(_InsufficientFunds value)? insufficientFunds,
    TResult? Function(_InvalidCard value)? invalidCard,
    TResult? Function(_StoreNotAvailable value)? storeNotAvailable,
    TResult? Function(_NoProductsAvailable value)? noProductsAvailable,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Unexpected value)? unexpected,
    TResult Function(_InsufficientFunds value)? insufficientFunds,
    TResult Function(_InvalidCard value)? invalidCard,
    TResult Function(_StoreNotAvailable value)? storeNotAvailable,
    TResult Function(_NoProductsAvailable value)? noProductsAvailable,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PaymentFailureCopyWith<$Res> {
  factory $PaymentFailureCopyWith(
          PaymentFailure value, $Res Function(PaymentFailure) then) =
      _$PaymentFailureCopyWithImpl<$Res, PaymentFailure>;
}

/// @nodoc
class _$PaymentFailureCopyWithImpl<$Res, $Val extends PaymentFailure>
    implements $PaymentFailureCopyWith<$Res> {
  _$PaymentFailureCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$_UnexpectedCopyWith<$Res> {
  factory _$$_UnexpectedCopyWith(
          _$_Unexpected value, $Res Function(_$_Unexpected) then) =
      __$$_UnexpectedCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_UnexpectedCopyWithImpl<$Res>
    extends _$PaymentFailureCopyWithImpl<$Res, _$_Unexpected>
    implements _$$_UnexpectedCopyWith<$Res> {
  __$$_UnexpectedCopyWithImpl(
      _$_Unexpected _value, $Res Function(_$_Unexpected) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_Unexpected implements _Unexpected {
  const _$_Unexpected();

  @override
  String toString() {
    return 'PaymentFailure.unexpected()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_Unexpected);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unexpected,
    required TResult Function() insufficientFunds,
    required TResult Function() invalidCard,
    required TResult Function() storeNotAvailable,
    required TResult Function() noProductsAvailable,
  }) {
    return unexpected();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unexpected,
    TResult? Function()? insufficientFunds,
    TResult? Function()? invalidCard,
    TResult? Function()? storeNotAvailable,
    TResult? Function()? noProductsAvailable,
  }) {
    return unexpected?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unexpected,
    TResult Function()? insufficientFunds,
    TResult Function()? invalidCard,
    TResult Function()? storeNotAvailable,
    TResult Function()? noProductsAvailable,
    required TResult orElse(),
  }) {
    if (unexpected != null) {
      return unexpected();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Unexpected value) unexpected,
    required TResult Function(_InsufficientFunds value) insufficientFunds,
    required TResult Function(_InvalidCard value) invalidCard,
    required TResult Function(_StoreNotAvailable value) storeNotAvailable,
    required TResult Function(_NoProductsAvailable value) noProductsAvailable,
  }) {
    return unexpected(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Unexpected value)? unexpected,
    TResult? Function(_InsufficientFunds value)? insufficientFunds,
    TResult? Function(_InvalidCard value)? invalidCard,
    TResult? Function(_StoreNotAvailable value)? storeNotAvailable,
    TResult? Function(_NoProductsAvailable value)? noProductsAvailable,
  }) {
    return unexpected?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Unexpected value)? unexpected,
    TResult Function(_InsufficientFunds value)? insufficientFunds,
    TResult Function(_InvalidCard value)? invalidCard,
    TResult Function(_StoreNotAvailable value)? storeNotAvailable,
    TResult Function(_NoProductsAvailable value)? noProductsAvailable,
    required TResult orElse(),
  }) {
    if (unexpected != null) {
      return unexpected(this);
    }
    return orElse();
  }
}

abstract class _Unexpected implements PaymentFailure {
  const factory _Unexpected() = _$_Unexpected;
}

/// @nodoc
abstract class _$$_InsufficientFundsCopyWith<$Res> {
  factory _$$_InsufficientFundsCopyWith(_$_InsufficientFunds value,
          $Res Function(_$_InsufficientFunds) then) =
      __$$_InsufficientFundsCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_InsufficientFundsCopyWithImpl<$Res>
    extends _$PaymentFailureCopyWithImpl<$Res, _$_InsufficientFunds>
    implements _$$_InsufficientFundsCopyWith<$Res> {
  __$$_InsufficientFundsCopyWithImpl(
      _$_InsufficientFunds _value, $Res Function(_$_InsufficientFunds) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_InsufficientFunds implements _InsufficientFunds {
  const _$_InsufficientFunds();

  @override
  String toString() {
    return 'PaymentFailure.insufficientFunds()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_InsufficientFunds);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unexpected,
    required TResult Function() insufficientFunds,
    required TResult Function() invalidCard,
    required TResult Function() storeNotAvailable,
    required TResult Function() noProductsAvailable,
  }) {
    return insufficientFunds();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unexpected,
    TResult? Function()? insufficientFunds,
    TResult? Function()? invalidCard,
    TResult? Function()? storeNotAvailable,
    TResult? Function()? noProductsAvailable,
  }) {
    return insufficientFunds?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unexpected,
    TResult Function()? insufficientFunds,
    TResult Function()? invalidCard,
    TResult Function()? storeNotAvailable,
    TResult Function()? noProductsAvailable,
    required TResult orElse(),
  }) {
    if (insufficientFunds != null) {
      return insufficientFunds();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Unexpected value) unexpected,
    required TResult Function(_InsufficientFunds value) insufficientFunds,
    required TResult Function(_InvalidCard value) invalidCard,
    required TResult Function(_StoreNotAvailable value) storeNotAvailable,
    required TResult Function(_NoProductsAvailable value) noProductsAvailable,
  }) {
    return insufficientFunds(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Unexpected value)? unexpected,
    TResult? Function(_InsufficientFunds value)? insufficientFunds,
    TResult? Function(_InvalidCard value)? invalidCard,
    TResult? Function(_StoreNotAvailable value)? storeNotAvailable,
    TResult? Function(_NoProductsAvailable value)? noProductsAvailable,
  }) {
    return insufficientFunds?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Unexpected value)? unexpected,
    TResult Function(_InsufficientFunds value)? insufficientFunds,
    TResult Function(_InvalidCard value)? invalidCard,
    TResult Function(_StoreNotAvailable value)? storeNotAvailable,
    TResult Function(_NoProductsAvailable value)? noProductsAvailable,
    required TResult orElse(),
  }) {
    if (insufficientFunds != null) {
      return insufficientFunds(this);
    }
    return orElse();
  }
}

abstract class _InsufficientFunds implements PaymentFailure {
  const factory _InsufficientFunds() = _$_InsufficientFunds;
}

/// @nodoc
abstract class _$$_InvalidCardCopyWith<$Res> {
  factory _$$_InvalidCardCopyWith(
          _$_InvalidCard value, $Res Function(_$_InvalidCard) then) =
      __$$_InvalidCardCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_InvalidCardCopyWithImpl<$Res>
    extends _$PaymentFailureCopyWithImpl<$Res, _$_InvalidCard>
    implements _$$_InvalidCardCopyWith<$Res> {
  __$$_InvalidCardCopyWithImpl(
      _$_InvalidCard _value, $Res Function(_$_InvalidCard) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_InvalidCard implements _InvalidCard {
  const _$_InvalidCard();

  @override
  String toString() {
    return 'PaymentFailure.invalidCard()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_InvalidCard);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unexpected,
    required TResult Function() insufficientFunds,
    required TResult Function() invalidCard,
    required TResult Function() storeNotAvailable,
    required TResult Function() noProductsAvailable,
  }) {
    return invalidCard();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unexpected,
    TResult? Function()? insufficientFunds,
    TResult? Function()? invalidCard,
    TResult? Function()? storeNotAvailable,
    TResult? Function()? noProductsAvailable,
  }) {
    return invalidCard?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unexpected,
    TResult Function()? insufficientFunds,
    TResult Function()? invalidCard,
    TResult Function()? storeNotAvailable,
    TResult Function()? noProductsAvailable,
    required TResult orElse(),
  }) {
    if (invalidCard != null) {
      return invalidCard();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Unexpected value) unexpected,
    required TResult Function(_InsufficientFunds value) insufficientFunds,
    required TResult Function(_InvalidCard value) invalidCard,
    required TResult Function(_StoreNotAvailable value) storeNotAvailable,
    required TResult Function(_NoProductsAvailable value) noProductsAvailable,
  }) {
    return invalidCard(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Unexpected value)? unexpected,
    TResult? Function(_InsufficientFunds value)? insufficientFunds,
    TResult? Function(_InvalidCard value)? invalidCard,
    TResult? Function(_StoreNotAvailable value)? storeNotAvailable,
    TResult? Function(_NoProductsAvailable value)? noProductsAvailable,
  }) {
    return invalidCard?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Unexpected value)? unexpected,
    TResult Function(_InsufficientFunds value)? insufficientFunds,
    TResult Function(_InvalidCard value)? invalidCard,
    TResult Function(_StoreNotAvailable value)? storeNotAvailable,
    TResult Function(_NoProductsAvailable value)? noProductsAvailable,
    required TResult orElse(),
  }) {
    if (invalidCard != null) {
      return invalidCard(this);
    }
    return orElse();
  }
}

abstract class _InvalidCard implements PaymentFailure {
  const factory _InvalidCard() = _$_InvalidCard;
}

/// @nodoc
abstract class _$$_StoreNotAvailableCopyWith<$Res> {
  factory _$$_StoreNotAvailableCopyWith(_$_StoreNotAvailable value,
          $Res Function(_$_StoreNotAvailable) then) =
      __$$_StoreNotAvailableCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_StoreNotAvailableCopyWithImpl<$Res>
    extends _$PaymentFailureCopyWithImpl<$Res, _$_StoreNotAvailable>
    implements _$$_StoreNotAvailableCopyWith<$Res> {
  __$$_StoreNotAvailableCopyWithImpl(
      _$_StoreNotAvailable _value, $Res Function(_$_StoreNotAvailable) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_StoreNotAvailable implements _StoreNotAvailable {
  const _$_StoreNotAvailable();

  @override
  String toString() {
    return 'PaymentFailure.storeNotAvailable()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_StoreNotAvailable);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unexpected,
    required TResult Function() insufficientFunds,
    required TResult Function() invalidCard,
    required TResult Function() storeNotAvailable,
    required TResult Function() noProductsAvailable,
  }) {
    return storeNotAvailable();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unexpected,
    TResult? Function()? insufficientFunds,
    TResult? Function()? invalidCard,
    TResult? Function()? storeNotAvailable,
    TResult? Function()? noProductsAvailable,
  }) {
    return storeNotAvailable?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unexpected,
    TResult Function()? insufficientFunds,
    TResult Function()? invalidCard,
    TResult Function()? storeNotAvailable,
    TResult Function()? noProductsAvailable,
    required TResult orElse(),
  }) {
    if (storeNotAvailable != null) {
      return storeNotAvailable();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Unexpected value) unexpected,
    required TResult Function(_InsufficientFunds value) insufficientFunds,
    required TResult Function(_InvalidCard value) invalidCard,
    required TResult Function(_StoreNotAvailable value) storeNotAvailable,
    required TResult Function(_NoProductsAvailable value) noProductsAvailable,
  }) {
    return storeNotAvailable(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Unexpected value)? unexpected,
    TResult? Function(_InsufficientFunds value)? insufficientFunds,
    TResult? Function(_InvalidCard value)? invalidCard,
    TResult? Function(_StoreNotAvailable value)? storeNotAvailable,
    TResult? Function(_NoProductsAvailable value)? noProductsAvailable,
  }) {
    return storeNotAvailable?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Unexpected value)? unexpected,
    TResult Function(_InsufficientFunds value)? insufficientFunds,
    TResult Function(_InvalidCard value)? invalidCard,
    TResult Function(_StoreNotAvailable value)? storeNotAvailable,
    TResult Function(_NoProductsAvailable value)? noProductsAvailable,
    required TResult orElse(),
  }) {
    if (storeNotAvailable != null) {
      return storeNotAvailable(this);
    }
    return orElse();
  }
}

abstract class _StoreNotAvailable implements PaymentFailure {
  const factory _StoreNotAvailable() = _$_StoreNotAvailable;
}

/// @nodoc
abstract class _$$_NoProductsAvailableCopyWith<$Res> {
  factory _$$_NoProductsAvailableCopyWith(_$_NoProductsAvailable value,
          $Res Function(_$_NoProductsAvailable) then) =
      __$$_NoProductsAvailableCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_NoProductsAvailableCopyWithImpl<$Res>
    extends _$PaymentFailureCopyWithImpl<$Res, _$_NoProductsAvailable>
    implements _$$_NoProductsAvailableCopyWith<$Res> {
  __$$_NoProductsAvailableCopyWithImpl(_$_NoProductsAvailable _value,
      $Res Function(_$_NoProductsAvailable) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_NoProductsAvailable implements _NoProductsAvailable {
  const _$_NoProductsAvailable();

  @override
  String toString() {
    return 'PaymentFailure.noProductsAvailable()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_NoProductsAvailable);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unexpected,
    required TResult Function() insufficientFunds,
    required TResult Function() invalidCard,
    required TResult Function() storeNotAvailable,
    required TResult Function() noProductsAvailable,
  }) {
    return noProductsAvailable();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unexpected,
    TResult? Function()? insufficientFunds,
    TResult? Function()? invalidCard,
    TResult? Function()? storeNotAvailable,
    TResult? Function()? noProductsAvailable,
  }) {
    return noProductsAvailable?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unexpected,
    TResult Function()? insufficientFunds,
    TResult Function()? invalidCard,
    TResult Function()? storeNotAvailable,
    TResult Function()? noProductsAvailable,
    required TResult orElse(),
  }) {
    if (noProductsAvailable != null) {
      return noProductsAvailable();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Unexpected value) unexpected,
    required TResult Function(_InsufficientFunds value) insufficientFunds,
    required TResult Function(_InvalidCard value) invalidCard,
    required TResult Function(_StoreNotAvailable value) storeNotAvailable,
    required TResult Function(_NoProductsAvailable value) noProductsAvailable,
  }) {
    return noProductsAvailable(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Unexpected value)? unexpected,
    TResult? Function(_InsufficientFunds value)? insufficientFunds,
    TResult? Function(_InvalidCard value)? invalidCard,
    TResult? Function(_StoreNotAvailable value)? storeNotAvailable,
    TResult? Function(_NoProductsAvailable value)? noProductsAvailable,
  }) {
    return noProductsAvailable?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Unexpected value)? unexpected,
    TResult Function(_InsufficientFunds value)? insufficientFunds,
    TResult Function(_InvalidCard value)? invalidCard,
    TResult Function(_StoreNotAvailable value)? storeNotAvailable,
    TResult Function(_NoProductsAvailable value)? noProductsAvailable,
    required TResult orElse(),
  }) {
    if (noProductsAvailable != null) {
      return noProductsAvailable(this);
    }
    return orElse();
  }
}

abstract class _NoProductsAvailable implements PaymentFailure {
  const factory _NoProductsAvailable() = _$_NoProductsAvailable;
}
